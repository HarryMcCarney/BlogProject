<html data-theme="light"></html><header><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@1.0.0/css/bulma.min.css"><script src="https://kit.fontawesome.com/fd17b6d7c8.js" crossorigin="anonymous"></script><link rel="stylesheet" href="styles.css"><link rel="preconnect" href="https://fonts.googleapis.com"><link rel="preconnect" href="https://fonts.gstatic.com"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Yrsa:ital,wght@0,300..700;1,300..700&amp;display=swap"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Merriweather:ital,wght@0,300;0,400;0,700;0,900;1,300;1,400;1,700;1,900&amp;display=swap"><script src="Script.js" type="module"></script></header><body class="has-background-light has-text-dark" onLoad="execScripts()" style="width:100%;--family-serif:&apos;Yrsa&apos;, serif;--family-secondary-serif:&apos;Merriweather&apos;, serif;--family-primary:var(--family-serif);--family-secondary:var(--family-secondary-serif);font-family:var(--family-primary);font-family:var(--family-secondary)"><section class="container is-fluid"><nav class="navbar is-fluid has-text-dark has-background-light" role="navigation" aria-label="main navigation"><div class="navbar-brand"><a id="navbar-burger" class="navbar-burger is-text" role="button" aria-label="menu" aria-expanded="false" data-target="navbarBasicExample"><span aria-hidden="true"></span><span aria-hidden="true"></span><span aria-hidden="true"></span><span aria-hidden="true"></span></a></div><div id="navbarBasicExample" class="navbar-menu navbar-end"><a class="navbar-item" href="about.html">About</a></div></nav><section class="container content is-medium has-text-dark" style="max-width:800px"><nav class="level mt-6"><div class="level-left"><div class="level-item"><span class="icon is-medium is-primary"><i class="fa-regular fa-circle is-primary" style="color:#00d1b2"></i></span><p class="ml-2 has-text-dark">Note</p></div></div></nav><div class="title is-size-1 mb-5 has-text-dark">Bayesian F# Series - The Monty Hall Paradox.</div><div class="subtitle is-size-3 is-family-secondary mb-6 has-text-dark" style="font-weight:350">This is the first in a series of posts exploring how Bayesian Techniques can be implemented in F#. It will also provide simple examples of how to started using Plotly.NET and FSharp.stats.</div><div class="columns mb-6"><div class="column is-two-thirds pr-2 has-text-dark"><span class="tag is-medium">Bayes</span><span class="tag is-medium">H&amp;C</span><span class="tag is-medium">F#</span><span class="tag is-medium">Data Science</span></div><div class="column is-one-third is-size-7 has-text-right has-text-dark" style="font-weight:350"><p>CREATED ABOUT 9 MONTHS AGO</p></div></div><div>
<h1>Introduction</h1>
<p>The posts will closely follow Allen Downey's excellent book Think Bayes. Each post will cover one or two chapters from his book summarising the key ideas and porting the examples to F#. The first few posts will hopefully be quite accessible and the complexity will increase as we progress though the book.</p>
<p>The goal is that any one with some knowledge of F# will be able to implement the Bayesian techniques covered in the real world.</p>
<h1>Why F#</h1>
<p>F# is an excellent language for Data Science. The rich static type system guides your thinking while you structure solutions to problems. It avoids the 'guess/refresh' approach sometimes found with loosely typed languages. Moreover, the extra precision of types that won't let you multiply strings, concatenate a boolean, or add an int to a float ensures your code is correct.</p>
<p>Lastly, functional immutable programming is simply a better conceptual fit for most data science work. Object oriented languages are primarily about managing state, not transforming data. F#’s functional first approach encourages us to write simple deterministic functions which are easy to understand and compose into larger and larger operations with no loss of readability.</p>
<h1>Data Science at Hack and Craft</h1>
<p>At Hack and Craft we build simulations for logistics and manufacturing companies. Typically they are interested in measuring the effects of proposed chances to their processes. We model these initiatives and run simulations to produce synthetic data. This data is then analysed to measure impact of the proposed changes.</p>
<p>We find Bayesian approaches very applicable to this work and have gradually moved away from a more traditional 'frequentist' approach.</p>
<h1>Bayesian thinking</h1>
<p>Frequentist techniques use ratios between the frequencies of possible cases of an observed sequence of data to derive their probability.</p>
<p>So the probability of a coin landing on heads is established by looking at a sequence of flips. Such as T, H, T, T, T, T, H, T, T, H, H, T. In this sequence there are 4 Heads and 8 Tails. SO the probability of Heads is 4/12 or 0.33. This conclusion feels wrong as we know that coins are normally evenly weighted and our conclusion that this is an uneven coin is based on a short sequence of data.</p>
<p>In the real world H&amp;C's clients often have partial and noisy data. And they nearly alway have some preexisting beliefs which should guide our analysis.</p>
<p>This is where Bayesian techniques can help. Instead of trying to calculate the probability of heads from the data, the Bayesian asks, given this data what the probability that this is a 50/50 coin. They can also ask what the probability that this is 33$ coin or a 66% coin.</p>
<p>These three coins represent three different hypotheses which are equally likely before we see the sequence of flips but not equally likely afterwards. Given that only 4/12 flips return heads we can infer that its now more likely that we have 33% coins than a 66% coin.</p>
<p>In this way our probability of having each coin can be updated using the observed data.</p>
<p>The formula for calculating this is known as Bayes Theorem. Its a complex theorem but the core idea is quite intuitive. Data allows us to update the probabilities of our competing beliefs. These beliefs are held with varying levels of certainty before we make observations and afterwards we change those convictions. This series of article will explore a variety of increasingly and sometimes complex but always practical applications of this approach.</p>
<h1>A Bayesian approach to the Monty Hall paradox</h1>
<p>The Monty Hall Paradox is a well known probability puzzle which many people find intuitively challenging. It has divided opinion even among experts. Bayesian thinking makes this puzzle much more tractable than traditional frequentist so its a an excellent place to start.</p>
<p>The puzzle is as follows: Imagine a game show. The host is called Monty. There are three doors. Behind one of the doors is a car which the contestant is trying to win. A contestant is asked to to choose a door. Then Monty opens one of the other two doors which doesn't have the car behind it. This leaves two doors left and the car is behind one of them. Monty then asks the contestant if they would like to stick with their original choice or switch to the other door. Most people will assume there is a 50/50 chance for both doors so there is nothing to be gain from switching. However, switching doors is a the better choice and raises the odds of winning to 2/3</p>
<p>Its hard to explain this with frequentist theory but a Bayesisn phrasing of the puzzle makes it intuitively clear that the contestant should switch.</p>
<p>But first for anyone skeptical about why the contestant should switch, which I was, heres empirical proof. The code below simulates the game 10k times. 5k with a switch strategy and 5k with a non switching strategy. THe graph shows the switcher wins almost exactly 66.6% of the time, while the non-switcher's odds remain on 33.3%. Later we will show how we can derive the same results analytically using Bayes rule.</p>
<h1>r "nuget: Plotly.NET.Interactive, 4.0.0"</h1>
<p>Installed Packages
Plotly.NET.Interactive, 4.0.0
Loading extensions from <code>C:\Users\harry\.nuget\packages\plotly.net.interactive\4.0.0\interactive-extensions\dotnet\Plotly.NET.Interactive.dll</code>
open System
open Plotly.NET</p>
<p>//Helpers
let rnd from until = Random().Next(from, until)</p>
<p>let rec rndExclude from until (excl: int list) =
let r = rnd from until</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">if</span> <span class="id">excl</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, '1', 1)" onmouseover="showTip(event, '1', 1)" class="m">List</span><span class="pn">.</span><span onmouseout="hideTip(event, '2', 2)" onmouseover="showTip(event, '2', 2)" class="id">contains</span> <span class="id">r</span> <span class="k">then</span>
    <span class="id">rndExclude</span> <span class="id">from</span> <span class="id">until</span> <span class="id">excl</span>
<span class="k">else</span>
    <span class="id">r</span>
</code></pre>
<p>//Domain
type Player =
| Switcher
| NonSwitcher</p>
<p>type Door =
| Door1
| Door2
| Door3</p>
<p>type Game =
{ Player: Player
CarLocation: Door
PlayersFirstChoice: Door option
MontyRevealed: Door option
PlayersFinalChoice: Door option
Winner: bool option }</p>
<p>//Actions
let getDoorNumber door =
match door with
| Door1 -&gt; 0
| Door2 -&gt; 1
| Door3 -&gt; 2</p>
<p>let createGame player : Game =
let r = rnd 0 3</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="pn">{</span> <span class="id">Player</span> <span class="o">=</span> <span class="id">player</span>
  <span class="id">CarLocation</span> <span class="o">=</span> <span class="pn">(</span><span class="pn">[</span> <span class="id">Door1</span><span class="pn">;</span> <span class="id">Door2</span><span class="pn">;</span> <span class="id">Door3</span> <span class="pn">]</span><span class="pn">[</span><span class="id">r</span><span class="pn">]</span><span class="pn">)</span>
  <span class="id">PlayersFirstChoice</span> <span class="o">=</span> <span onmouseout="hideTip(event, '3', 3)" onmouseover="showTip(event, '3', 3)" class="id">None</span>
  <span class="id">MontyRevealed</span> <span class="o">=</span> <span onmouseout="hideTip(event, '3', 4)" onmouseover="showTip(event, '3', 4)" class="id">None</span>
  <span class="id">PlayersFinalChoice</span> <span class="o">=</span> <span onmouseout="hideTip(event, '3', 5)" onmouseover="showTip(event, '3', 5)" class="id">None</span>
  <span class="id">Winner</span> <span class="o">=</span> <span onmouseout="hideTip(event, '3', 6)" onmouseover="showTip(event, '3', 6)" class="id">None</span> <span class="pn">}</span>
</code></pre>
<p>let makeFirstChoice (game: Game) : Game =
let r = rnd 0 3</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="pn">{</span> <span class="id">game</span> <span class="k">with</span>
    <span class="id">PlayersFirstChoice</span> <span class="o">=</span> <span onmouseout="hideTip(event, '4', 7)" onmouseover="showTip(event, '4', 7)" class="id">Some</span><span class="pn">(</span><span class="pn">[</span> <span class="id">Door1</span><span class="pn">;</span> <span class="id">Door2</span><span class="pn">;</span> <span class="id">Door3</span> <span class="pn">]</span><span class="pn">[</span><span class="id">r</span><span class="pn">]</span><span class="pn">)</span> <span class="pn">}</span>
</code></pre>
<p>let montyRevealsDoor (game: Game) : Game =
let chosenDoor = getDoorNumber game.PlayersFirstChoice.Value
let carDoor = getDoorNumber game.CarLocation
let r = rndExclude 0 3 [ chosenDoor; carDoor ]</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="pn">{</span> <span class="id">game</span> <span class="k">with</span>
    <span class="id">MontyRevealed</span> <span class="o">=</span> <span onmouseout="hideTip(event, '4', 8)" onmouseover="showTip(event, '4', 8)" class="id">Some</span><span class="pn">(</span><span class="pn">[</span> <span class="id">Door1</span><span class="pn">;</span> <span class="id">Door2</span><span class="pn">;</span> <span class="id">Door3</span> <span class="pn">]</span><span class="pn">[</span><span class="id">r</span><span class="pn">]</span><span class="pn">)</span> <span class="pn">}</span>
</code></pre>
<p>let decideToSwitch game : Game =
match game.Player with
| Switcher -&gt;
let montyRevealed = getDoorNumber game.MontyRevealed.Value
let playersFirstChoice = getDoorNumber game.PlayersFirstChoice.Value
let r = rndExclude 0 3 [ montyRevealed; playersFirstChoice ]</p>
<pre class="fssnip highlighted"><code lang="fsharp">    <span class="pn">{</span> <span class="id">game</span> <span class="k">with</span>
        <span class="id">PlayersFinalChoice</span> <span class="o">=</span> <span onmouseout="hideTip(event, '4', 9)" onmouseover="showTip(event, '4', 9)" class="id">Some</span><span class="pn">(</span><span class="pn">[</span> <span class="id">Door1</span><span class="pn">;</span> <span class="id">Door2</span><span class="pn">;</span> <span class="id">Door3</span> <span class="pn">]</span><span class="pn">[</span><span class="id">r</span><span class="pn">]</span><span class="pn">)</span> <span class="pn">}</span>
<span class="pn">|</span> <span class="id">NonSwitcher</span> <span class="k">-&gt;</span>
    <span class="pn">{</span> <span class="id">game</span> <span class="k">with</span>
        <span class="id">PlayersFinalChoice</span> <span class="o">=</span> <span class="id">game</span><span class="pn">.</span><span class="id">PlayersFirstChoice</span> <span class="pn">}</span>
</code></pre>
<p>let isWinner (game: Game) =
{ game with
Winner = Some(game.CarLocation = game.PlayersFinalChoice.Value) }</p>
<p>let play player =
createGame player
|&gt; makeFirstChoice
|&gt; montyRevealsDoor
|&gt; decideToSwitch
|&gt; isWinner</p>
<p>let games = 10000</p>
<p>let results =
[ 0..games ]
|&gt; List.map (fun i -&gt; if (i % 2 = 0) then Switcher else NonSwitcher)
|&gt; List.map play
|&gt; List.filter (fun g -&gt; g.Winner.Value)
|&gt; List.countBy (fun g -&gt; (g.Player = Switcher))</p>
<p>let switchers = results |&gt; List.find fst |&gt; snd
let nonSwitchers = results |&gt; List.find (fun (s, w) -&gt; s = false) |&gt; snd</p>
<p>Chart.Column(
values = [ float switchers / float (games / 2); float nonSwitchers / float (games / 2) ],
Keys = [ "Switchers"; "Non Switchers" ]
)</p>
<p>So how can we explain this using a Bayesian approach. As we saw with the coin example, we think of the car being behind each door as distinct hypotheses. Hypothesis 1 is 'car is behind door 1', Hypothesis 2 is the 'car is behind door 2', Hypothesis 3 the 'car is behind door 3'. The probability of the car being behind each door at the start of the game is 0.33. And lets say we chose door 1 as our first choice.</p>
<p>To summarise</p>
<p>Hypothesis	Probability	First Choice
| H1 | 0.33 | X | H2 | 0.33 | | H3 | 0.33 |</p>
<p>Monty has to open a door and he selects door 3. Now comes the key step in all applications of Bayes rule, we update the probabilities of the competing Hypotheses based on the data. In this case the data is that Monty selected door 3. The likelihood that he would have selected door 3 is actually different for each hypothesis.</p>
<p>For Hypothesis one, Monty wont open the door that we have chosen so he is left with a choice of doors 2 and 3. So, for H1, there is a 50/50 chance of him opening door 3. However, for H2 there is a 100% chance that Monty opens door 3. He wont open the door you have chosen, door 1, or the door that the car is behind, door 2 in this hypothesis, so he has to open door 3. Lastly there is 0% chance of the car being behind door 3 as he opened this one and he wont open the door that the car is behind it.</p>
<p>So, after Monty opens door three we have the following updated table.</p>
<p>Hypothesis	Probability	First Choice	Likelihood of opening door 3
H1	0.33	X	0.5
H2	0.33		1
H3	0.33		0
First application of Bayes rule in F#
Bayes rule tells us to simply multiply the initial probability known as the 'Prior' by the likelihood of the hypothesis given the new data. This gives a new probability known as the 'unormalised Posterior'. We then normalise the Posteriors to give their relative chance. A rough F# implementation would be look as follows.</p>
<p>open System</p>
<p>type Prior =
{ Hypothesis: string
Prior: float
Likelihood: float }</p>
<p>type Posterior =
{ Hypothesis: string
Prior: float
Likelihood: float
Posterior: float }</p>
<p>let calcPosteriors (priors: Prior list) : Posterior list =
let totalProbability = priors |&gt; List.sumBy (fun r -&gt; r.Prior * r.Likelihood)</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="id">priors</span>
<span class="o">|&gt;</span> <span onmouseout="hideTip(event, '1', 10)" onmouseover="showTip(event, '1', 10)" class="id">List</span><span class="pn">.</span><span onmouseout="hideTip(event, '5', 11)" onmouseover="showTip(event, '5', 11)" class="id">map</span> <span class="pn">(</span><span class="k">fun</span> <span class="id">h</span> <span class="k">-&gt;</span>
    <span class="pn">{</span> <span class="id">Hypothesis</span> <span class="o">=</span> <span class="id">h</span><span class="pn">.</span><span class="id">Hypothesis</span>
      <span class="id">Prior</span> <span class="o">=</span> <span class="id">h</span><span class="pn">.</span><span class="id">Prior</span>
      <span class="id">Likelihood</span> <span class="o">=</span> <span class="id">h</span><span class="pn">.</span><span class="id">Likelihood</span>
      <span class="id">Posterior</span> <span class="o">=</span> <span class="pn">(</span><span class="pn">(</span><span class="id">h</span><span class="pn">.</span><span class="id">Prior</span> <span class="pn">*</span> <span class="id">h</span><span class="pn">.</span><span class="id">Likelihood</span><span class="pn">)</span> <span class="o">/</span> <span class="id">totalProbability</span><span class="pn">)</span> <span class="pn">}</span><span class="pn">)</span>
</code></pre>
<p>let montyPriors =
[
{ Hypothesis = "H1"
Prior = 0.3333333333
Likelihood = 0.5
}
{ Hypothesis = "H2"
Prior = 0.3333333333
Likelihood = 1 }
{ Hypothesis = "H3"
Prior = 0.3333333333
Likelihood = 0
} ]</p>
<p>let montyPosteriors =  montyPriors |&gt; calcPosteriors</p>
<p>let rds (n: float)=
Math.Round (n,3) |&gt; string</p>
<p>Chart.Table(
headerValues = ["<b>Hypothesis</b>"; "<b>Probability</b>";"<b>Likelihood of opening door 3</b>"; "<b>Posterior</b>"],
cellsValues = (montyPosteriors |&gt; List.map( fun p -&gt; [p.Hypothesis; rds p.Prior; rds p.Likelihood; rds p.Posterior]))
)
As you can see the posterior result matches the results from empirical simulation.</p>
<p>Wrap up
Bayesian thinking gives us intuitive and powerful ways to approach probability problems. This article has followed the first couple of chapters of the Think Bayes book which is an excellent resource well worth reading in full.</p>
<p>The next post in this series will look at how Bayes rule can be applied to more complex examples. We will also show how the fsharp.stats library can help compose and solve these problems with remarkable efficiency.</p>
<div class="fsdocs-tip" id="1">Multiple items<br />module List

from Microsoft.FSharp.Collections<br /><br />--------------------<br />type List&lt;&#39;T&gt; =
  | op_Nil
  | op_ColonColon of Head: &#39;T * Tail: &#39;T list
  interface IReadOnlyList&lt;&#39;T&gt;
  interface IReadOnlyCollection&lt;&#39;T&gt;
  interface IEnumerable
  interface IEnumerable&lt;&#39;T&gt;
  member GetReverseIndex: rank: int * offset: int -&gt; int
  member GetSlice: startIndex: int option * endIndex: int option -&gt; &#39;T list
  static member Cons: head: &#39;T * tail: &#39;T list -&gt; &#39;T list
  member Head: &#39;T
  member IsEmpty: bool
  member Item: index: int -&gt; &#39;T with get
  ...</div>
<div class="fsdocs-tip" id="2">val contains: value: &#39;T -&gt; source: &#39;T list -&gt; bool (requires equality)</div>
<div class="fsdocs-tip" id="3">union case Option.None: Option&lt;&#39;T&gt;</div>
<div class="fsdocs-tip" id="4">union case Option.Some: Value: &#39;T -&gt; Option&lt;&#39;T&gt;</div>
<div class="fsdocs-tip" id="5">val map: mapping: (&#39;T -&gt; &#39;U) -&gt; list: &#39;T list -&gt; &#39;U list</div>

</div></section><footer class="footer has-text-dark has-background-light"><div class="content has-text-centered"><p><strong>Content</strong> by <a style="color:#363636;text-decoration:underline;font-weight:bold;transition-duration:300ms;transition-property:color;transition-timing-function:ease" href="https://mastodon.sdf.org/@HarryMcCarnney">Harry McCarney</a>. The source code is licensed <a href="http://opensource.org/licenses/mit-license.php">MIT</a>. The website content is licensed <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY NC SA 4.0</a>.</p></div></footer></section></body>